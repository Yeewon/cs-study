브라우저가 HTML, CSS, 자바스크립트로 작성된 텍스트 문서를 어떻게 파싱(해석) 하여 브라우저에 렌더링하는지 알아보자.

### 파싱

프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 **텍스트 문서의 문자열을 토큰(token)으로 분해(어휘 분석)** 하고, 토근에 문법적인 의미와 구조를 반영하여 트리 구조의 자료구조인 **파스 트리를 생성**하는 일련의 과정

### 렌더링

HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 **브라우저에 시각적으로 출력**하는 것

## 브라우저 렌더링 과정

### 1. 브라우저는 렌더링에 필요한 `리소스를 요청` 하고 `서버로부터 응답` 을 받는다.

### 2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 `DOM과 CSSOM을 생성`한다.

### 3. DOM과 CSSOM을 결합하여 `렌더링 트리를 생성` 한다.

### 4. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 `AST를 생성하고 바이트코드로 변환하여 실행`한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다.

> **AST** = Abstract Syntax Tree

### 5. 변경된 DOM과 CSSOM은 `렌더 트리로 결합`된다.

### 6. 렌더 트리를 기반으로 `HTML 요소의 레이아웃(위치와 크기)을 계산`하고 `브라우저 화면에 HTML 요소를 페인팅`한다.

## 요청과 응답

- 렌더링에 필요한 리소스는 모두 서버에 존재한다.
- 필요한 리소스(HTML, CSS, 자밥스크립트, 이미지, 폰트) 등의 정적 파일 또는 서버가 동적으로 생성한 데이터)를 서버에 요청하고 서버로부터 응답받는다.

1. **브라우저의 주소창이 URL 입력**
2. **URL의 호스트 이름이 DNS를 통해 IP 주소로 변환**
3. **IP 주소를 갖는 서버에게 요청을 전송**

**왜 index.html뿐만 아니라 요청도 하지 않은 CSS, 자바스크립트, 이미지, 폰트 파일들도 응답되었을까?**

브라우저의 렌더링 엔진이 HTML을 파싱하는 도중에 외부 리소스를 로드하는 태그를 만나면 HTML 파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청하기 때문이다.

## HTTP 1.1과 HTTP 2.0

HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약)이다.

### HTTP/1.1

- 커넥션당 하나의 요청과 응답만 처리한다.
- 여러 개의 리소스 요청이 개별적으로 전송되고 응답 또한 개별적으로 전송된다.
- 리소스의 동시 전송이 불가능한 구조이므로 요청할 리소스의 개수에 비례하여 응답 시간도 증가하는 단점이 있다.

### HTTP

- 커넥션당 여러 개의 요청과 응답이 가능하다. 👉 HTTP/1.1에 비해 페이지 로드 속도가 약 50% 빠르다.

## HTML 파싱과 DOM 생성

<aside>
💡 DOM은 HTML 문서를 파싱한 결과물이다.

</aside>

- 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트다.
- 렌더링 엔진은 HTML 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조(객체)인 DOM으로 변환하여 메모리에 저장해야 한다.

1. 서버에 존재하던 **HTML 파일이 응답**된다.
2. 브라우저는 HTML 문서를 바이트(2진수) 형태로 응답받는다.

   meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 **문자열로 변환**된다.

3. 문자열로 변환된 HTML 문서를 읽어 들여 **토큰들로 분해**한다.

   > **토큰** : 문법적 의미를 갖는 코드의 최소 단위

4. 각 토큰을 객체로 변환하여 노드를 생성한다.

   > **노드** : DOM을 구성하는 기본 요소

5. HTML 문서는 HTML 요소들의 집합으로 이루어진다. HTML 요소 간의 부자 관계를 반영하여 **트리 자료구조를 DOM을 구성**한다.

## CSS 파싱과 CSSOM 생성

HTML과 동일한 파싱 과정(바이트 → 문자 → 토큰 → 노드 → CSSOM)을 거치며 해성하여 CSSOM을 생성한다.

- 렌더링 엔진은 HTML을 파싱하여 DOM을 생성해 나가다가 CSS 로드하는 태그를 만나면 DOM 생성을 일시 중단한다.

## 렌더 트리 생성

**DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다.**

- 렌더 트리는 `HTML 요소의 레이아웃(위치와 크기)를 계산`하는데 사용되며 브라우저 화면에 픽셀을 렌더링하는 `페인팅처리`에 입력된다.
- 레이아웃 계산과 페인팅이 재차 실행되는 경우
  1. 자바스크립트에 의한 노드 추가 또는 삭제
  2. 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
  3. HTML 요소의 레이아웃(위치, 크기)에 변경을 발생시키는 width/height, margin,padding 등의 스타일 변경

<aside>
💡 리렌더링이 빈번하게 발생하지 않도록 주의할 필요가 있다.

</aside>

## 자바스크립트 파싱과 실행

- 자바스크립트 파일을 서버에 요청하면 로드한 자바스크립트 파일이나 sscript 태그 내의 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘긴다.
- 렌더링 엔진이 HTML과 CSS를 파싱하여 DOM과 SSOM을 생성하듯이 자바스크립트 엔진은 자바스크립트를 해석하여 AST(추상적 구문 트리)를 생성한다.
- AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다.

## 리플로우와 리페인트

`리플로우` : 레이아웃 계산을 다시 하는 것. 레이아웃에 영향을 주는 변경이 발생한 경우에 한하여 실행.

`리페인트` : 재결합된 렌더 트리를 기반으로 다시 페인트 하는 것.

## 자바스크립트 파싱에 의한 HTML 파싱 중단

- 렌더링 엔진과 자바스크립트 엔진은 **직렬적으로 파싱을 수행**한다.

**자바스크립트를 body 요소의 가장 아래에 위치시키는 이유?**

1. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있다.
2. 자바스크립트 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.
